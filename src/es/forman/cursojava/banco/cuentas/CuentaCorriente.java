package es.forman.cursojava.banco.cuentas;


//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : CuentaCorriente.java
//  @ Date : 16/03/2006
//  @ Author : 
//
//
public class CuentaCorriente extends Cuenta implements Comparable {
	private CuentaCredito cuentaCredito;
	private CuentaAhorro cuentaAhorro;
	private float limiteInferior;					// Mínimo de dinero que queremos tener en la cuenta
	private float limiteSuperior;				// Máximo de dinero que queremos tener; si lo superamos, se transfiere automáticamente a la cuenta de ahorro.
	
	public CuentaCorriente(float cantidadInicial, String numeroCuenta) {
		super(cantidadInicial, numeroCuenta);
		this.cuentaAhorro = new CuentaAhorro(this, "AH"+numeroCuenta);
	}
	
	/**
	 * @see Cuenta
	 * @return Devuelve:0 si no es posible; 1 si es posible; 2 si es posible pero es necesario sacarlo de la cuenta asociada; 
	 * 3 si es posible pero es necesario llegar hasta la cuenta de crédito para sacarlo.
	 */
	public int reintegra (float cantidad, boolean ejecuta) {
		if (this.isDisponible(cantidad))  {
			if (ejecuta)
				this.setSaldo(this.getSaldo() - cantidad);
			return 1;
		}
		else	{	// No hay dinero suficiente: comprobar si tenemos en la cuenta de ahorro lo que nos falta
			float faltante = cantidad - this.getDisponible();
			int resultado = this.getCuentaAhorro().reintegra(faltante, ejecuta);
			if (resultado != 0 && ejecuta)		// Se ha podido sacar de las otras cuentas
				this.setSaldo(this.getSaldo() - cantidad + faltante);		// Retira el dinero
			return resultado;
		}
	}
		
	/**
	 * @return true si hay una cuenta de crédito disponible y su disponible es mayor que 0.
	 */
	public boolean isCuentaCreditoDisponible() {
		return this.getCuentaCredito() != null && this.getCuentaCredito().getDisponible() > 0;
	}
	
	public float getTipoInteres() {
		return 0.0f;
	}
	
	/**
	 * Abre una cuenta de crédito asociada. Sólo la abre si no tiene ya una y si puede satisfacer la comisión de
	 * disponibilidad, que se carga directamente a las cuentas del usuario (corriente y en su caso a la de ahorro).
	 */
	public void abreCuentaCredito() {
		if (this.getCuentaCredito() != null)
			return;
		this.setCuentaCredito(new CuentaCredito(this));
	}
	
    /**
     * Sobreescribe el método por defecto, ya que tiene en cuenta el límite inferior que pudiéramos haber establecido.
     * @return saldo menos el límite inferior
     */
    public float getDisponible() {
    	return this.getSaldo() - this.getLimiteInferior();
    }
    
    /**
     * Establece el límite inferior de la cuenta. Nunca podrá estar por debajo de este límite.
     * @param cantidad
     * @return false si no ha podido establecer el límite, true en caso contrario.
     */
    public boolean setLimiteInferior(float cantidad) {
    	if (this.getSaldo() < cantidad)		
    		return false;
    	this.limiteInferior = cantidad;
    	return true;
    }
    
    public float getLimiteInferior() {
    	return this.limiteInferior;
    }
    
    /**
     * Establece el límite superior. Lo que supere esta cantidad se pasará a la cuenta de ahorro
     * de manera automática, al hacer ingresos.
     * @param cantidad
     * @return false si el limite superior es menor que el inferior.
     */
    public boolean setLimiteSuperior(float cantidad) {
    	if (cantidad < this.getLimiteInferior())
    		return false;
    	this.limiteSuperior = cantidad;
    	if (this.getSaldo() > cantidad)  {		// Si el saldo supera el máximo del límite, traspasa el resto a la cuenta de ahorro.
    		float sobrante = cantidad-getSaldo();
    		this.traspasa(IFCuenta.INGRESO_AHORRO, sobrante);
    	}
    	return true;
    }

    public void setCuentaCredito(CuentaCredito cuentaCredito) {
		this.cuentaCredito = cuentaCredito;
	}

	public CuentaCredito getCuentaCredito() {
		return cuentaCredito;
	}

	public IFCuenta getCuentaAhorro() {
		return cuentaAhorro;
	}
	
    /**
     * Realiza un traspaso de una cuenta a otra. Un traspaso es una transacción en la que realizamos una resta de una cuenta,
     * y una suma en la otra. Primero se comprueba que el reintegro es posible.
     * @param destino Cuenta a la que se traspasa desde la actual.
     * @param cantidad Cantidad a traspasar
     * @return Código del resultado del traspaso
     * @see Constantes INGRESO_
     */
    public int traspasa(int destino, float cantidad) {
    	// Si la cantidad no está disponible, vuelve sin realizar el traspaso
    	if (!this.isDisponible(cantidad))
    		return IFCuenta.INGRESO_NOK;
    	// Una vez aquí, sabemos que la cantidad está disponible: la traspasamos
    	switch(destino) {
    	case IFCuenta.INGRESO_AHORRO:
    		this.cuentaAhorro.setSaldo((this.cuentaAhorro.getSaldo() + cantidad));
    		this.setSaldo(this.getSaldo()-cantidad);
    		break;
    	case IFCuenta.INGRESO_AHORRO_RESTO:
    		this.cuentaAhorro.setSaldo((this.cuentaAhorro.getSaldo() + cantidad));
    		break;
    	case IFCuenta.INGRESO_CREDITO:
    		if (this.cuentaCredito != null) {
    			float maximoEnCredito = CuentaCredito.CREDITO_INICIAL - cuentaCredito.getSaldo();
    			// Rellena todo lo que puede, hasta el máximo de 3000
    			if (maximoEnCredito > cantidad)
    				this.cuentaCredito.ingresa(cantidad);
    			else	{// La cantidad es más de lo que falta en el crédito: el resto lo traspasamos a la cuenta de ahorro.
    				this.cuentaCredito.ingresa(maximoEnCredito);
    				this.traspasa(IFCuenta.INGRESO_AHORRO_RESTO, cantidad - maximoEnCredito);
    			}
    		}
    		this.setSaldo(this.getSaldo()-cantidad);
    		break;
    	}
		return destino;
    }	
    
        public boolean equals(Object o){ //defino el equals correctamente
    	/*if (!(o instanceof CuentaCorriente))
    		return false;
    	Cuenta aux=(CuentaCorriente)o;
    	return this.getNumero().equals(aux.getNumero());*/
    	if (o==null) return false;
    	if ((!(o instanceof CuentaCorriente))||(!(o instanceof String)))
    		return false;
    	try{
    		Cuenta aux=(CuentaCorriente)o;
    		return this.getNumero().equals(aux.getNumero());
    	}
    	catch (ClassCastException ce){
    		String sNumeroCuenta=(String)o;
    		return this.getNumero().equals(sNumeroCuenta);
    	}
    }
    
    public int hashCodecode(){
    	int i=this.getNumero().hashCode();
    	return i;
    }

 
    /* toString: No hace falta sobreescribir algo que ya tenemos en        superclase y no queramos añadirle informacion adicional
       de la hija, así que este método me lo podría haber ahorrado
    public String tostring() {
    	return this.getNumero();
    }*/
    
    /**
     * reescribimos compareTo para que las cuentas sean
     * comparables, util para usar una coleccion donde queramos
     * tener la cuentas ordenadas 
     */
    public int compareTo(Object arg0) {
		if (arg0 == null)
			throw new NullPointerException(); 
		if (!(arg0 instanceof CuentaCorriente))
			throw new ClassCastException();
		CuentaCorriente cc = (CuentaCorriente)arg0;
		return (this.getNumero().compareTo(cc.getNumero()));
	}
}
